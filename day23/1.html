<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        //浏览器运行代码的时候，会分配一个线程来执行代码，代码分为 同步代码 和异步代码
        //  代码执行的时候 如果遇到异步的任务会放到异步任务 队列中
        //     当主线程执行完成 主任务之后，去异步任务队列 中看看有没有 符合输出条件的任务



        // let p1=new Promise((resolve,reject)=>{
        //resolve()执行会把当前的promise变成成功态
        //reject()执行会把当前的promise变成失败态
        //    setTimeout(()=>{
        //       resolve();
        //    },2000)
        // });

        // p1.then(()=>{},()=>{});
        //then 中的回调函数执行时异步的
        //promise 的实例有三种状态 pending等待  fulfilled成功 reject失败
        //状态 一旦发生变化 就会凝固，不会再变
        //pending--->fulfilled
        //pending--->reject


        //---------------
        // setTimeout((ss)=>{
        // console.log(ss);
        // },1000,100)
        // setTimeout函数的第三个参数是传递给回调函数的实参


        // console.log(100);
        // let p1 = new Promise((resolve, reject) => {
        //     console.log(800);
        //     setTimeout(() => {
        //         console.log(700);
        //         resolve()
        //     });
        //     reject();
        // });
        // console.log(200);
        // p1.then(() => {
        //     console.log(300);
        // }, () => {
        //     console.log(400);
        // });
        // console.log(500);


            //--------------------------------------
    let p1 = new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve()
        // reject()
        // 第一个请求
      });
    });
    p1.then(() => {
      console.log('第一次成功');
      return new Promise((resolve,reject)=>{
        resolve()
      })
    },()=>{
      console.log('第一次失败');
    }).then(() => {
      console.log(500);
      // 发送第三次请求了
    },()=>{
      console.log('第二次失败');
    }).then(()=>{
      console.log(600);
    })

        //当前then中的回调函数执行的时候，如果没有返回promise的实例 那么下一个then中的成功的回调函数（第一个函数）会默认执行
        // 当前then中的回调函数执行的时候，如果返回了promise的实例 那么下一个then中的回调函数 就由上一个返回了promise的实例接管
    </script>

</body>

</html>