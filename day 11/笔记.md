## 全局变量和window关系
【es6】阻断了与window的关系
针对：var function 直接写一个变量名，都是给window添加了一个这样的属性，属性值就是变量值

## es6
1) 没有变量提升 但是在代码自上而下执行之前，会有一个词法检测。来看你的代码是不是会有语法错误，如果有直接报错
console.log(1); 此行不打印  报错
var a=3;
let a=6;

2）阻断了window的关系
3）不能重复声明
4）暂时性死区：
    在声明变量之前的那个区域是不允许访问此变量，一旦访问就是报错

## 上级作用域：
    上级作用域是谁，跟在哪里执行没有关系，跟他在哪儿定义有关系
    C的上机作用域就是B B的上级作用域就是A A的上级作用域就是window
    例子
    function A(){
        function B(){
            function C(){

            }
        }
    }
## 堆内存的释放
    谷歌浏览器标记法：每隔一段时间就会检测一下引用空间地址是否被占用，
    如果没有被占用，在空闲的时候就会被释放掉
    ie和火狐浏览器：当一个空间地址被占用一次，就累加1，如果不被占用了，减1，直到为0的时候，就会释放掉

    如何让堆内存不被占用？
    var obj={"name":"li"}
    .....
    obj=null;
## 栈内存的释放
    全局栈内存：当页面关闭的时候
    函数执行形成的栈内存：
    1）一般是都是执行完毕后就销毁了
    function fn(){
        console.log(1)
    }
    fn()
    2) 不销毁：栈内存里面有一个引用数据类型的值，并且被外面的变量占用
    ```
    function fn(x){
        return function(y){
            return x+y;
        }
    }
    var f=fn(1);

    ```

    ```
    var ary=[];
    function fn(){
        ary=[1,2,3];
    }
    fn();
## 闭包
    当一个函数执行，形成了一个私有作用域，保护里面的私有变量不受外界打扰，这种机制就叫做闭包
    在市场上大部分人口中的闭包：当一个函数执行的时候，
    里面有一个引用数据类型被外界占用了，形成了不销毁作用域
    例如：
    function fn(x){
        return function(y){
            return x+y;
        }
    }
    var f=fn(1);

## 闭包的作用
    保护：保护自己的私有作用域中的变量不受外界的打扰
    保存：因为形成了不销毁的作用域，可以保存里面的私有变量

## 闭包在实战中的应用
var utils=(function(){
    var num=0;
    function fn1(){
        console.log(1)
    }
    return {
        fn1:fn1
    }
})();
